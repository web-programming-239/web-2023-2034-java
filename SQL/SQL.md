### Храним данные в Excel
Представим, что мы не программисты, а менеджеры. Люди массово жалуются на то, что очень трудно найти кабинет для занятия, приходится постоянно бегать и искать свободный и нам нужно хоть как-то решить эту проблему. Одно из простых решений - завести табличку в экселе, в которую все, кто хочет провести занятие, должны записаться. Тогда выглядеть она будет примерно так:
![img](attachments/Pasted%20image%2020230215164729.png)

В целом решении рабочее, но 
1) Если записей станет не 10, а 100, работать с такой таблицей будет не очень удобно. Например, как нам узнать, забронирован ли кабинет 208 с 12:00 до 13:00 26.11.2023? Придётся глазами просмотреть всю таблицу
2) Мы то всё-таки программисты, и нам хочется написать программу, которая будет с этой таблицей работать. Не очень понятно, как это сделать

Обе эти проблемы решаются заменой Excel на Реляционную базу данных

**Реляционная база данных** - это, грубо говоря, множество данных, организованных в таблички
Множество табличек - база данных. 
Для нашего примера таблица выглядела бы так:
![img](attachments/Pasted%20image%2020230216183452.png)
Работа с реляционной базой данных осуществляется при помощи **SQL** запросов


### SQL базы данных
Чем SQL база данных отличается от табличек в Excel?
1) В SQL базе данных явно существуют типы. Многие из них совпадают с известными вам типа из других языков (например, из Java)
	- int, float, double, datetime, boolean
	- не все:
	-  String в базе данных нету. Вместо него есть varchar(n) - где n - Это максимальная длина строки. Например varchar(50). Также есть тип text, его нужно использовать для больших строк. еще есть longtext для очень больших строк
1) В отличии от Excel у баз данных изначально нет графического представления и возможность редактировать что-то мышкой (хотя некоторые программы, в том числе ~~idea~~, vscode с плагинами такую возможность предоставляют). Всё взаимодействие с базами данных происходит при помощи SQL

SQL - Structured query language. Язык запросов. То есть формально, это язык, но он совершенно непохож на языки программирования которые вы видели до этого.

Посмотрим, как он работает. 
В SQL обычно оперируют не целой программой, а отдельными командами, которые что-то делают.

#### Select
Например, при помощи команды select можно достать информацию из базы данных
```sql
select * from reservations;
```
`reservations` - название таблицы
`*` - значит вывести все колонки, которые есть в таблице. При желании, можно явно указать, какие поля нам нужны:
```sql
select classNumber, purpose from reservtations;
```

Также можно выводить только те строки, которые удовлетворяют определённому условию:
```sql
select * from reservations where classNumber = '108';
```
Строки здесь пишутся обязательно в одинарных кавычках
```sql
select * from reservations where startTime > '2023-11-22 09:00' and classNumber = '303';
```
Тут можно сравнивать даты. Дату нужно писать в определённом формате, иначе не сработает

Также вывод можно сортировать:
```sql
select * from reservations where startTime > '2023-11-22 09:00' and classNumber = '303' order by startTime;
```
Можно сортировать по нескольким колонкам
```sql
select * from reservations where startTime > '2023-11-22 09:00' and classNumber = '303' order by classNumber, startTime;
```

#### Insert
Чтобы добавить строчку в таблицу используется команда `insert`
```sql
insert into reservations (classNumber, teacherFio, purpose, startTime, endTime)  
values ('108', 'Лянгузов Ф.А.', 'занятие 1', '2023-12-23 10:00', '2023-12-23 11:00');
```
- `(classNumber, teacherFio, purpose, startTime, endTime)` - это перечисление колонок, которые будут определены в новой записи. Можно указывать не все, тогда в пропущенных автоматически установится значение `null`.
- `('108', 'Лянгузов Ф.А.', 'занятие 1', '2023-12-23 10:00', '2023-12-23 11:00')` - перечисление конкретных значений для новой строки.

Можно добавлять сразу несколько значений
```sql
insert into reservations (classNumber, teacherFio, startTime, endTime)  
values ('108', 'Лянгузов Ф.А.', '2023-12-23 10:00', '2023-12-23 11:00'),
		('108', 'Лянгузов Ф.А.', '2023-12-24 10:00', '2023-12-24 11:00');
```

#### Update
Уже существующие строки можно обновлять при помощи команды `update`
```sql
update reservations set purpose = 'test' where endTime = '2023-12-24 11:00';
```
- `where` здесь работает аналогично `select`. 
- устанавливать можно несколько значений
```sql 
update reservations set purpose = 'test', classNumber = '123' where endTime = '2023-12-24 11:00';
```
#### Delete
При помощи delete можно удалить строку или несколько строк
```sql
delete from reservations where endTime = '2023-12-24 11:00';
```

Если нужно очистить таблицу целиком можно использовать `truncate`
```sql
truncate reservations;
```


### Редактирование структуры бд
Все команды до этого позволяли менять данные в конкретной таблице, теперь посмотрим, как можно менять структуру базы: добавлять и удалять таблицы, менять уже существующие

#### Create table
```sql
create table `reservations`  
(  
    classNumber varchar(32),  
    teacherFio  varchar(128),  
    purpose     varchar(1024),  
    startTime   datetime,  
    endTime     datetime  
);
```
- вначале указывается название поля, потом его тип

#### Drop table
```sql
drop table reservations;
```
- В отличии от `truncate` удаляет всю таблицу, а не только данные в ней. После `truncate` остается пустая таблица, в которую ещё можно что-то вставить, после `drop` не остается ничего

### Alter table
`alter` используется для изменения существующих объектов (вообще не только таблиц, но пока остановимся на таблицах)
```sql
alter table reservations add column test_field text;
```
- в таблицу добавится новая колонка. Во всех существующих строках `test_field` будет `null`
```sql
alter table reservations_simple drop column classNumber;
```

#### Primary key, foreign key

Давайте добавим ещё одну таблицу - `rooms`. В ней будем хранить список кабинетов
```sql
create table rooms (  
    classNumber varchar(32) primary key,  
    floor_number int,  
    capacity int  
);
  
insert into rooms (classNumber, floor_number, capacity) VALUES ('303', 3, 15), ('208', 2, 30), ('108', 3, 15)
```
Каждый кабинет в списке может быть только один раз (потому что 2 кабинета с одинаковым номером - это странно). Значит поле `classNumber` однозначно идентифицирует строку.  Такую колонку называют `primary key`. Её значение не может быть пропущено при добавлении строки и не может повторяться. 

Теперь по сути по `classNumber` из `reservations` мы можем взять строку из `rooms`. Но что если в reservations окажется кабинет, которого нет в списке: например, он был раньше, но мы его удалили. Или просто опечатались создавая новое бронирование. Чтобы таких проблем не было, нужно показать базе данных, что classNumber в `reservations` и `rooms` - это одно и то же. Для этого используется `foreign key`
```sql
alter table reservations add foreign key (classNumber) references rooms (classNumber);
```
Теперь база данных не даст создать бронирование на несуществующий кабинет или удалить кабинет, для которого существуют бронирования

#### Autoincrement
Для `rooms` в качестве pk (primary key) отлично подходит `classNumber`, но что делать с `reservations`? В таких случаях добавляют поле id. Чтобы самостоятельно не следить за ним, можно сделать эту колонку `auto_increment` - тогда база данных сама всегда вставляет значение на 1 больше предыдущего.
```sql
create table test
(  
    id int auto_increment primary key,  
    test_field text  
);
insert into test (test_field) value ('123')
```
- Значение id не указываем

### Join
Представим, что у нас есть 2 таблицы:
```sql
create table users (
	id int auto_increment primary key,  
    username text,
    age int
);

create table orders (
	id int auto_increment primary key,  
	user_id int,
	content text
):

insert into users (username, age) values 
	('user1', 10),  
	('user2', 19),
	('user3', 20);

insert into orders (user_id, content) values 
	(0, 'order1'),
	(1, 'order2'),
	(10, 'order3')
```
и мы хотим вывести все заказы от людей, старше 18 лет. Как это можно сделать? Для этого есть _join_

```sql
select * from users u inner join odrers o on o.users_id = u.id where u.age > 18;
```
В полученной таблице будут все колонки из `users` и все колонки из `orders`
Если вам нужны определённые, их можно указать, как и в обычном селекте
```sql
select o.id, o.content, u.id from users u inner join odrers o on o.users_id = o.id where u.age > 18;
```

Обратите внимание, что в результате будут `inner join`  выдаёт только только те строки, что есть и в 1 и во 2 (пересечение). В нашем случае результат будет такой:
```
|	o.id    |    o.content    |    u.id    |
-------------------------------------------|
|	  1     |    'order2'     |      1     |
```
Помимо inner join'а есть outer join

```sql
select o.id, o.content, u.id from odrers o left outer join users u on o.users_id = o.id where u.age > 18;

```
Он выведет все строки из левой таблицы (в данном случае users). Если какой-то строке не соответствует строка из правой таблицы, он подставит null
```
|	o.id    |    o.content    |    u.id    |
-------------------------------------------|
|	  0     |    'order1'     |    null    |
|	  1     |    'order2'     |      1     |
|	  2     |    'order3'     |    null    |
```
Аналогично, есть `right oute join`
Ещё есть `full outer join`, он выведет всё, что можно (как left и right сразу)
### Как подключиться
1) зайти на http://84.38.180.130:8080/reg.html
2) ввести придумать имя и пароль
3) нажать "на показать данные для подключения"
4) перейти в vs code
5) установить плагин database client https://www.youtube.com/watch?v=rJYUTxD-2-M
6) создать подключение
7) должно получиться так
![](attachments/Pasted%20image%2020231206205207.png)
10) чтобы писать запросы нажимаем open query (иконка листа на картинке)

### Задания
1) Посмотрите на список бронирований, отсортируйте его по кабинетам и по времени начала.
2) Добавьте в таблицу `reservations_simple` каких-нибудь значений
3) Обновите в таблице `reservations_simple` столбец purpose на 'test' у всех бронирований между '2023-11-22' и '2023-12-22'
4) Добавьте в таблицу `reservations_simple` столбец `old` типа `boolean`. Поставьте true для всех бронирований до сегодняшней даты
5) Воссоздать структуру системы для бронирования кабинетов: таблицы `reservations`, `rooms`, `teachers`
- Таблица `reservations` и `rooms` у вас уже есть. 
- Нужно добавить таблицу `teachers` с полями: id, name, middle_name, last_name
6) удалите теперь уже не нужную таблицу `reservations_simple`
7) добавьте каких-нибудь значений в таблицу `teachers`, главное чтобы учителей было хотя бы 3
8)  Теперь можно сделать `teacherId` в `reservations` foreign key, ссылающимся на id в `teachers`
9) Попробуйте добавить в `reservations` бронирование, ссылающееся на не существующего учителя. Убедитесь, что не получается. Добавьте бронирование правильно. Убедитесь, что получается
10) Выведете для каждого бронирования (нужно использовать join):
- Номер кабинета
- фио учителя
- цель
11) Выведете для каждого бронирования(нужно джоинить сразу 3 таблицы):
- Номер кабинета
- вместимость кабинета
- фио учителя
- цель
12) у меня есть еще доп задания