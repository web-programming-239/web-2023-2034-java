  
Прежде всего стоит ответить, зачем? Объектно-ориентированная идеология разрабатывалась как попытка связать поведение сущности с её данными и спроецировать объекты реального мира и бизнес-процессов в программный код. Задумывалось, что такой код проще читать и понимать человеком, т. к. людям свойственно воспринимать окружающий мир как множество взаимодействующих между собой объектов, поддающихся определенной классификации. Удалось ли идеологам достичь цели, однозначно ответить сложно, но де-факто мы имеем массу проектов, в которых с программиста будут требовать ООП.

### Что такое класс и объект
**Класс** - описание свойств каких-то схожих объектов.
**Объект** в Java - экземпляр какого-то класса

У классов могут быть поля и методы. 
Чтобы создать экземпляр класса используют слово new

```java
MyClass myObject = new MyClass() // new, название класса со скобками
// здесь мы конкретный объект, экземпляр класса MyClass и положили его в переменную myObject
// Тип переменной myObject в данном случае совпадает с классом создаваемого объект
// Так бывает очень часто, хотя и не всегда

myObject.someMethod() // вызов метода у объекта
myObject.someField = 10 // обращение к значению поля объекта
```

### Поля и методы
На прошлом занятии мы использовали функции и переменные
```java
public class Main {  
    public static void main(String[] args) {  
        int v1 = 10;  
        int v2 = 15;
        System.out.println(res(v1, v2));
    }

}
// так выглядит использование переменных и функций
```

```java
public class Main {  
    public static void main(String[] args) {  
        myObject.v1 = 10;  
        myObject.v2 = 15;
        System.out.println(myObject.res(v1, v2));
    }

} // а так - полей и методов
```


### Объявление классов
1) Классы нужно объявлять каждый в своём отельном файле. Название файла должно совпадать с названием класса (с точностью до расширения `.java`)
2) классы нужно называть с заглавной буквы

Поля, объявленные в классе будут у всех объектов этого класса 
Причем при объявлении поля, мы указываем только тип, а у экземпляра класса у всех полей обязательно будут конкретные значения

Методы класса могут работать с этими значениями (на первый взгляд выглядит странно, мы в методе `res` обращаемся к неинициализированным переменным field1 и field2). Так можно делать, как раз потому что у экземпляра класса у этих полей будут значения


```java
public class MyClass { 
	public int field1; // объявление поля класса
	// что делает public пока неважно, просто пишем
	public int field2;
	
	public int res () {
		return field1 + field2;
		// тоже самое, что и 
		// return this.field1 + this.field2
		// this можно опускать
	}
}
```

Откуда эти значения берутся

### Конструктор
_Конструктор класса_ - это метод, который будет вызван автоматически при создании класса. В нём нужно присвоить полям класса конкретные значения. Этот метод может принимать аргументы - тогда они будут требоваться при создании класса.

```java
public class MyClass {
	public MyClass(int field1, int field2) {  
	    this.field1 = field1;  
	    this.field2 = field2;  
	}
	
	public int field1;
	public int field2;
	
	public int res () {
		return field1 + field2;
	}
}
```
Здесь конструктор класса `MyClass` принимает 2 аргумента и кладёт переданные ему значения в поля объекта. 
this используется для обращения к конкретному объекту, у которого вызывается метод
```java

// где-то в другом файле
MyClass myObject = new MyClass(1, 2);
myObject.res() // ??
myObject.field1 // ??
```
### Static
Ещё раз вспомним разницу между классом и объектом:

```java
public class MyClass { 
	public int field1; 
	public int field2;
	
	public int res () {
		return field1 + field2;
	}
}
```
`MyClass` - это класс
- название с большой буквы
- нет конкретных значений полей, обращаться к ним нельзя
- методы вызывать нельзя
```java
MyClass.field1; // нельзя
MyClass.field1 = 10; // так тоже нельзя
MyClass.res(); // и так нельзя
```
Вместо этого нужно
```java
MyClass myObject = new MyClass();

myObject.field1 = 10; // вот так уже можно
myObject.field2 = 15;
myObject.res(); // 25
```
`myObject` - это объект
- название с маленькой буквы
- можно работать с полями как с обычными переменными
- можно вызывать методы

Если нужно, чтобы переменная была "привязана" именно к классу, а не к объектам этого класса, можно сделать её статической
```java
public class MyClass { 
	public static int MY_CONSTANT = 15;
}
```

Обычно это используется для объявления каких-то констант или вместо *глобальных переменных*, которых в java в чистом виде нет

```java
System.out.println(MyClass.MY_CONSTANT); // теперь так можно
MyClass.MY_CONSTANT = 10; // так тоже
```

**статические переменные**
- обычно называются заглавными буквами
- обращаться к ним нужно через название класса

### Практика
- Создайте класс, хранящий в себе число, и имеющий метод `int op(String operation, int value)`, а также `void print()`
- Создайте массив таких "чисел", добавьте к каждому из них какие-нибудь значение, выведете все получившиеся числа
- Добавьте в класс константу `MAX_VALUE`, при каждой операции проверяйте, что получающееся значение меньше `MAX_VALUE`

### Задания
- Создайте класс `Student` с полями `name` и `surname`
- Создайте класс `ClassRoom` с полем `students`. Это должен быть массив объектов типа `Student`
- Добавьте классу `students` метод `sudentsInside`, выводящий все элементы массива `students`
- Добавьте классу `students` метод `newStudent`, принимающий в качестве аргумента объект типа `Student` и добавляющий его в массив 
- Добавьте классу `ClassRoom` поле `capacity`.  
- Добавьте метод `notFull`, возвращающий `true`, если количество элементов в массиве `students` меньше, чем `capacity - 1`. Теперь перед добавлением ученика в методе `newStudent` проверяйте, что в кабинете есть место, иначе выведете сообщение в консоль (о том, что мест нет)
- Создайте класс `School` с полем `classRooms` (массив `ClassRoom`'ов). Создайте класс `Constants` со **статическим полем** `AVERAGE_CLASSROM_CAPATICTY`. Добавьте метод `addClassRoom`, **ничего не принимающий**. Он должен добавлять в массив `classRooms` новый объект `ClassRoom` (`capacity` должен быть равен `AVERAGE_CLASSROM_CAPATICTY`, массив `students` пустой)
- Добавьте классу `School` метод `newStudent`, принимающий в качестве аргумента объект типа `Student` и добавляющий его в первый свободный `classRoom`. Если мест нигде нет, напишите об этом в консоль