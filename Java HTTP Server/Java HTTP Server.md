HTTP сервер - это программа, которая должна уметь на HTTP запросы. Для этого мы:
1) Создадим "хендлеры" - объекты, которые умеют обрабатывать определенные запросы
2) Повесим каждый хендлер на определенный путь (http://test.com/some-path /some-path называется относительным путём сайта)

### HttpHandler
в java есть специальный интерфейс для хендлеров - `HttpHandler`.  Выглядит он так:

```java
public interface HttpHandler {  
	public abstract void handle (HttpExchange exchange) throws IOException;  
}
```

Метод `handle` должен уметь обрабатывать HTTP запрос.
Он ничего не возвращает и принимает `HttpExchange` - объект, содержащий в себе всю информацию об обрабатываемом запросе:
- `getRequestMethod()` - возвращает метод обрабатываемого запроса ("GET", "POST", и тд)
- `getRequestHeaders()` - возвращает хедеры запроса (пока что нам не понадобится)
- `getRequestBody()` - возвращает `InputStream` (поток данных, из которого можно по частям считывать информацию. Обратите внимание, что после считывания из потока информация исчезает, её нужно обязательно сохранять в другие переменные, если вы планируете использовать её в будущем)
- `getResponseHeaders()` - возвращает `Headers` - объект, позволяющий добавлять хедеры ответа (нам пока не понадобится)
- `sendResponseHeaders(int, long)` - метод, который должен быть обязательно вызван, иначе ответ сервера будет некорректным
- `getResponseBody()` - возвращает `OutputStream` - объект, позволяющий записать информацию в тело ответа (синтаксис похож на работу с файлом, но вместо сохранения на диск, записанная информация будет передана по сети)

Рассмотрим простейшую реализацию этого метода
```java
public void handle(HttpExchange t) throws IOException {  
    String response = "Hello, World!";  
    t.sendResponseHeaders(200, 0);  // 200 - код ответа
    // 0 - размер тела ответа. в данном случае, 0 значит "разберитесь сами"
    // этот метод можно вызвть ТОЛЬКО 1 РАЗ, поэтому делать это нужнов самом конце
    OutputStream os = t.getResponseBody(); // кладём в переменную os поток данных тела ответа, в которй будем писать
    os.write(response.getBytes()); // пишем
    // почему не просто os.write(response)? в поток данных нужно передавать байты, ничего другое не подойдёт, поэтому нужно превести строку в байты
    os.close();  // по аналогии с закрыванием файла после работы с ним, этот поток данных тоже нужно закрыть
}
```

Этот хендлер на любой запрос возвращает строку "Hello, World!"

### HttpServer
Теперь созданный хендлер нужно научиться вызывать при запросах. Для этого используется класс `HttpServer` - объект, объединяющий в себе все хендлеры и настраивающий роутинг (маршрутизацию) между ними

Рассмотрим простейший сценарий использования:
```java
HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0);  // 8000 - порт, на котором будет поднят сервер
// 0 - просто пишем
server.createContext("/", new MyHandler()); // тут мы вешаем хендлер на все запросы, начинающиеся с "/". В данном случае, под условие подходит любой запрос
server.setExecutor(null); // просто пишем 
server.start(); // запускаем сервер
// если этого не сделать, выполнение программы просто завершится
```

Какой из хендлеров вызовется в таком случае при запросе на `/test`?
```java

server.createContext("/", new MyHandler1());

```

### Параметры
Часто, просто ссылки серверу недостаточно, чтобы правильно выполнить запрос (например, запрос на поиск первых _n_ пользователей, которых зовут _name_). В таких случаях используют параметры (они же аргументы)

В GET запросах аргументы кодируются прямо в адресную строку. Запрос с аргументами выглядит примерно так:
`http://test.com/search?name=test&n=15`
В java они обычно преобразуются в объект типа `Map<String, String>`

### Ошибки
что будет, если создать такой хендлер?
```java
static class ParamsHandler implements HttpHandler {  
    @Override  
    public void handle(HttpExchange t) throws IOException {  
        System.out.println(1 / 0);
    }  
}
```
ничего хорошего. сервер в ответ на запрос не вернёт ничего, браузер не поймёт, что делать (он то ожидает ответа, а ответа нет).
Поэтому, всё нужно обернуть в `try-catch` и в случае ошибки вернуть ответ с кодом 500:
```java
static class ParamsHandler implements HttpHandler {  
    @Override  
    public void handle(HttpExchange t) throws IOException {  
	    try {
	        System.out.println(1 / 0);
		} catch (Exception e) {
			String res = "Сервер сгорел :(";
			httpExchange.sendResponseHeaders(500, 0);
			OutputStream os = httpExchange.getResponseBody();  
			os.write(res.getBytes(StandardCharsets.UTF_8));  
			os.close();
		}
    }  
}
```

Но
1) Получается очень громоздко
2) Есть ещё ряд проблем (например, кодировки), которые нужно решить. Поэтому в примере проекта, который вы скачаете будет класс `BaseHandler`, **ИСПОЛЬЗУЙТЕ ЕГО**

В нём есть методы:
- `response(int code, String text)` - формирует ответ сервера
- `params()` - если в запросе были параметры, вернёт их в виде `Map<String, String>`

С использованием этого класса хендлер будет выглядеть более аккуратно:
```java
static class MyHandler extends BaseHandler {  
    @Override  
    protected void handleImpl(HttpExchange t) throws IOException {  
        response(200, "Hello, world!");  
    }  
}
```


### Практика
Создайте сервер, который 
- принимает запрос на '/params' и возвращает значение параметра `test`
- принимает запрос на '/hello' и возвращает HTML страницу
- на любой другой запрос возвращает 404
### Задания
- Создайте сервер, который:
	- возвращает "Hello world" на запрос "/hello-world" 
	- возвращает "pong" на запрос "/ping"
	- возвращает ошибку 404 с любым текстом на любой другой запрос
- Создайте сервер, который:
	- на GET запрос на "/hello" принимает параметр `name` возвращает "hello, \*name\*"
- Создайте сервер, который на GET запрос (любой) возвращает не просто строку, а HTML страницу(любую), которая будет корректно отображаться в браузере (Можно использовать [многострочные комментарии](https://www.baeldung.com/java-multiline-string)).
- Создайте сервер, который 
	- На запрос '/user' принимает параметр `name` возвращает HTML (можно красивую) страницу с именем пользователя
- Создайте сервер, который
	- Хранит в себе список пользователей (Создайте класс User с логином и паролем)
	- На запрос '/reg' создает нового пользователя и добавляет его в список
	- На запрос '/users'  возвращает HTML страницу со списком пользователей
- Добавьте сохранение списка пользователей в файл, при запуске сервера загружайте информацию из этого файла (чтобы информация не терялась при перезапуске сервера)