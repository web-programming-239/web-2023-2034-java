### Наследование
На прошлом занятии мы создавали простейший класс:
```java
public class MyClass { 
	public int field1;
	public int field2;
	
	public int res () {
		return field1 + field2;
	}
}
```
мы выяснили, что `field1` и `field2` - это поля, а `res()` - Это метод класса. Больше у этого класса полей и методов нет. 
```java
MyClass myObject = new MyClass();
myObject.toString() // будет ли здесь ошибка?
```
Казалось бы, мы объявили только метод `res()`, откуда взялся `toString()`?
Это возможно благодаря **наследованию**
**_Наследование_** - это концепция, согласно которой одни классы, называемые родительскими, могут лежать в основе других — дочерних. При этом, **дочерние классы перенимают свойства и поведение своего родителя**.
В Java любой созданный класс является _наследником_ (или _дочерним классом_) класса `Object`, поэтому у любого объекта будут несколько методов, **унаследованных** от класса `Object`, в частности `toString()`

Посмотрим, как мы можем явно унаследовать класс от другого
```java
public class MyChildClass extends MyClass {
	// extends - ключевое слово, используемое для указания родительского класса
	public int anotherRes() { 
		return field1 - field2; // тут мы обращаемся к полям, не объявленным в класса MyChildClass
		// это работает, потому что они объявлены в MyClass
	}
}
```

```java
MyChildClass myObject = new MyChildClass();
myObject.field1 = 10;
myObject.field2 = 2;
myObject.anotherRes(); 
myObject.res(); // ???
```

### Переопределение
Выше мы объявили метод `anotherRes()`, название которого ни с чем не конфликтует, но что если попытаться объявить в наследнике метод, который уже есть в предке (в нашем случае метод `res()`)?
```java
public class MyAnotherChildClass extends MyClass {
	public int res() { 
		return field1 - field2;
	}
}
```

```java
MyAnotherChildClass myObject = new MyAnotherChildClass();
myObject.res() // ??
```

Чтобы явно обозначать такие ситуации, над переопределяемыми методами принято писать _аннотацию_
`@Override`

```java
public class MyAnotherChildClass extends MyClass {
	@Override
	public int res() { 
		return field1 - field2;
	}
}
```

### Отличие типа от класса
До сих пор, объявляя переменные мы писали название класса дважды:
```java
MyClass /*тут*/ myObject = new MyClass() /*и тут*/;
```
зачем?

на самом деле, **тип переменной** (слева) и **тип объекта** (справа) могут не совпадать
**Тип переменной** показывает какие _поля_ и _методы_ будет **точно иметь объект**, лежащий в этой переменной
**Тип объекта** может отличаться от типа переменной, главное чтобы **объект**, который мы кладем в переменную **точно имел все поля и методы, описанные в типе переменной**

Поэтому можно делать так:
```java
MyClass myObject = new MyChildClass();
```
Тут в переменную типа `MyClass` (имеет поля `filed1`, `field2` и метод `res()`) мы кладём объект типа `MyChildClass` (имеет поля `filed1`, `field2` и метод `res()` _унаследованные_ от родителя и метод `anotherRes()`, явно объявленный в классе `MyChildClass`)

```java
myObject.field1; // ??
myObject.res(); // ??
myObejct.anotherRes(); // ??
```

Кладя **наследника** в переменную типа **родителя** мы **сужаем** функциональность объекта
```java
MyClass myObject = new MyChildClass();
myObejct.anotherRes(); // нельзя
myObject = new MyClass(); // тут мы ничего не нарушаем

myObejct.anotherRes(); // а вот что произошло бы тут неясно
// поэтому так делать НЕЛЬЗЯ
```

По научному обращение с классом-наследником так, будто это класс-родитель называется _полиморфизмом_

### Интерфейсы
Раз тип переменной используется компилятором только чтобы понять, какие поля методы должны быть у объекта, лежащего в этой переменной, получается можно объявлять классы, в которых будут описываться методы, но не будет их реализации. Такие классы называются **интерфейсами**. 
```java
public interface MyInterface {  
    public int res();  // обычно после названия  метода идет его реализация в {}
    // но так как это интерфейс, реализации метода тут быть не должно
}
```
В интерфейсах объявляются методы, **поля не объявляются**

```java
public interface MyInterface {  
    public int res();  
    int field1; // так нельзя
}
```
 
Теперь создадим класс, _реализующий_ этот интерфейс

```java
public class MyClass implements MyInterface { 
	public int field1;
	public int field2;
	
	public MyClass(int f1, int f2) {
		this.field1 = f1;
		this.field2 = f2;
	}
	
	public int res () {
		return field1 + field2;
	}
}
```
Вместо `extends` используется ключевое слово `implements`

Теперь можно делать так:
```java
MyInterface myObject = new MyClass(10, 5);
myObject.res()
```

На самом деле, вы уже встречались с этим, так например класс `ArrayList` является реализацией _интерфейса_ `List`, поэтому можно делать вот так:

```java
List<Integer> ints = new ArrayList<>();
```

Кстати за `ArrayList<Integer> ints = new ArrayList<>();` с сегодняшнего дня начинаем бить по рукам


### Практика
- Создайте интерфейс, для класса-обертки над числом, имеющий методы `int op(int value)`, а также `void print()`
- Создайте 2 реализации этого класса, для сложения и для вычитания
- Создайте массив таких "чисел", вызовете `op()` у каждого элемента этого массива
- Обратите внимание, что реализация метода `print()` в обоих случаях одинаковая. С помощью наследования избавьтесь от копипасты
### Задания

Для сдачи каждого задания нужно написать небольшую программу (в файле `Main.java`), проверяющую, что  написанные вами классы работают.

-  Создайте класс `Fruit` с полем `int weight`. Создайте классы-наследники: `Apple` и `Orange`. Переопределите метод `toString()` для каждого класса так, чтобы он возвращал название фрукта. Создайте массив фруктов разных типов и выведите на экран название каждого фрукта.
- Создайте интерфейс `FruitContainer` с методами 
	- `void put()` - добавляет фрукт в контейнер
	- `Fruit get()` - удаляет фрукт из контейнера и возвращает
	- `boolean isFull()` - проверяет, есть ли ещё место в контейнере
	- `boolean isEmpty()` - проверяет, есть ли что-нибудь в контейнере
- Создайте реализации этого интерфейса: 
	- `SmallContainer`, в который можно положить один фрукт. У него должно быть поле `Fruit fruit`. 
	- `InfiniteSizeContainer`. У него должно быть поле `List<Fruit> fruits`, в которое можно добавлять любое количество фруктов
	- `FixedSizeContainer`. У него должно быть поле `Fruit[] fruits`. В конструкторе нужно принимать вместимость контейнера. 
- Создайте класс `FruitShop`. У него должно быть поле `FruitContainer container` и  методы
	- `Fruit sellFruit()`,  достающий фрукт из контейнера, если он не пуст и выводящий сообщение в консоль в противном случае
	- `void addFruitToContainer(Fruit fruit)`, добавляющий фрукт в контейнер, если в нём есть место и выводящий сообщение в консоль в противном случае
	- `void addFruitsToContainer(List<Fruit> fruits)`, добавляющий все фрукты из массива, пока в контейнере есть место, и выводящий сообщение в консоль в противном случае

